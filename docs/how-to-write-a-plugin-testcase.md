# How to write agent plugin test case
## Overview
This test cases are based on real instrumentation, and verify the segments which are generated by the plugin and agent core.
By that, the test framework will call the HTTP endpoint provided by test case, and use [mock-collector](https://github.com/SkywalkingTest/skywalking-mock-collector)¹ to simulate the backend, which could receive and log all generated segments. Then the test framework will check the trace segments that whether they are same as expected.

## Test case repository structure
Test case repository includes all the test cases. Each case is in an independent folder, and also an independent maven project. The maven project is used to build a docker image, which is required to provide a HTTP endpoint as an entry.

Each test case should look like this.
```
[plugin_testcase]
  |__ [config]
  | |__ docker-compse.yml
  | |__ expectedData.yaml
  |__ [src]
  | |__ [main]
  | |    ...
  | |__ [resources]
  | |    ...
  |__ pom.xml
  |__ testcase.yml

[] = directory
```

### The usage of files in test case

The following setting files are required.

| File Name               | Usage                                                     |
|:-----|:---                                                      |
| docker-compose.xml | Define the docker compose env used in test           |
| expectedData.yaml  | Define the check rules about the expected trace segment.            |
| testcase.yml       | Define the metadata of test, such as test case name, version         |

## The workflow to write test case
1. Code the test case
2. Build and package test case. Test the image and make sure the agent and your plugin work.
3. Set your expected segment data check rules.
4. Build your test case metadata file.
5. Run the test case.

## Example
Here we are using HttpClient plugin as an example. 

HttpClient plugin is required to test two important points.
1. Span generated by HttpClient plugin.
1. The context propagation across HttpClient plugin works.

So the test including two servlets `Case Servlet` and `ContextPropagateServlet`.
The `Case Servlet` use HttpClient componenent to a distributed call to `ContextPropagateServlet`.

```
+-------------+         +------------------+            +-------------------------+
|   Browser   |         |  Case Servlet    |            | ContextPropagateServlet |
|             |         |                  |            |                         |
+-----|-------+         +---------|--------+            +------------|------------+
      |                           |                                  |
      |                           |                                  |
      |       WebHttp            +-+                                 |
      +------------------------> |-|         HttpClient             +-+
      |                          |--------------------------------> |-|
      |                          |-|                                |-|
      |                          |-|                                |-|
      |                          |-| <--------------------------------|
      |                          |-|                                +-+
      | <--------------------------|                                 |
      |                          +-+                                 |
      |                           |                                  |
      |                           |                                  |
      |                           |                                  |
      |                           |                                  |
      +                           +                                  +
```

### Code your case

Best practice in pom.xml:
1. The target component version should be set by maven properties
1. The image version should be set by maven properties
1. Keep image version as same as target component version

Take [this](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/pom.xml#L16-L17) as the example

### Build the case docker image
1. Add maven docker plugin. 

Pay attention the following fields.

| Field           | Comment                                                                                             |
| ---             | ---                                                                                            |
| imageName       | Image name, recommend style `skywalking/xxx-scenario`, Such as httpClient case should be named `skywalking/httpclient-scenario`|
| dockerDirectory | The folder used to build image, recommend `${project.basedir}/docker`     |
| imageTags       | The image version, use maven properties, and as same as target component version. |

2. Prepare Dockerfile. This is totally based on your case scenario. 

HttpClient test case DockerFile is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/tree/master/httpclient-4.3.x-scenario/docker)

3. Prepare docker-compose.xml. Create Docker-compose.xml in config folder

HttpClient test case docker-compose.xml is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/config/docker-compose.yml)

4. Run maven docker plugin

> mvn package docker:build

5. Test the case
- Run `docker-compose up` in `config` folder.
- Open the browser and access the HTTP endpoint opened in your case.

### Active SkyWalking agent

1. Add `VOLUME` of agent in Dockerfile, example is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/docker/Dockerfile#L11)

2. Add `-javaagent` in your startup script

HttpClient test is hosted in Tomcat, so the `-javaagent` should be added in `${project.basedir}/docker/catalina.sh`.
Example is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/docker/catalina.sh#L107-L110)

3. Add mock-collector image¹
- Add mock-collector in your docker-compose
- Set your test case use mock-collector as backend

Example is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/config/docker-compose.yml#L19-L31)

4. Adjust the port and image version in docker-compose.xml to variables.
- Set version to `{CASES_IMAGE_VERSION}`
- Set port to `{SERVER_OUTPUT_PORT}`

5. Add `volumes` for agent in docker-compose

Example is [here](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/config/docker-compose.yml#L13-L14)

6. Run test after we finish the expected data rule settings.

### Expected data file
HttpClient test case expected data file --- [expectedData.yaml](https://github.com/SkywalkingTest/skywalking-agent-testcases/blob/master/httpclient-4.3.x-scenario/config/expectedData.yaml)

#### Expected data
Expected data file is used to describe the agent data, cinluding register and segment data. In segment verify, include verifying span, segment number, etc.

Before we introduce the expected data file format, we should new the verify OP(s)

**Verify OP(s) for number**

| 描述符  | 描述               |
| :---     | :---               |
| `nq`     | not equal            |
| `eq`     | equal(default) |
| `ge`     | greater and equal           |
| `gt`     | greater than               |

**Verify OP(s) for String**

| 描述符     | 描述                   |
| :---       | :---                   |
| `not null` | not null               |
| `null`     | null or empty string       |
| `eq`        | equal(default) |

Now, let's see the expected data format.

**Register expected data format**
```yml
registryItems:
  applications:
  - SERVICE_CODE: SERVICE_ID(int)
  ...
  instances:
  - APPLICATION_CODE: INSTANCE_COUNT(int)
  ...
  operationNames:
  - APPLICATION_CODE: [ SPAN_OPERATION(string), ... ]
  ...
```


| Field         | Comment                                                                |
| :---           | :---                                                                |
| applications   | Service Code and its register id, but since it can't be expected in many cases, just set not 0|
| instances      | The number of service instace                                             |
| operationNames | Expected OperationNames of Span, which are sent to register      |


**Segments expected data format**
```yml
segments:
-
  applicationCode: APPLICATION_CODE(string)
  segmentSize: SEGMENT_SIZE(int)
  segments:
  - segmentId: SEGMENT_ID(string)
    spans:
        ....
```

以下对各个校验字段的描述:

| 字段            | 描述                                               |
| :---            | :---                                               |
| applicationCode | 待校验Segment的ApplicationCode.                    |
| segmentSize     | 待校验Segment的ApplicationCode生成的Segment的数量. |
| segmentId       | segment的trace ID.                                 |
| spans           | segment生成的Span列表                              |

**Span数据校验格式**

**注意**: 期望文件中Segment的Span是按照Span的结束顺序进行排列

```yml
    operationName: OPERATION_NAME(string)
    operationId: SPAN_ID(int)
    parentSpanId: PARENT_SPAN_ID(int)
    spanId: SPAN_ID(int)
    startTime: START_TIME(int)
    endTime: END_TIME(int)
    isError: IS_ERROR(string: true, false)
    spanLayer: SPAN_LAYER(string: DB, RPC_FRAMEWORK, HTTP, MQ, CACHE)
    spanType: SPAN_TYPE(string: Exit, Entry, Local )
    componentName: COMPONENT_NAME(string)
    componentId: COMPONENT_ID(int)
    tags:
    - {key: TAG_KEY(string), value: TAG_VALUE(string)}
    ...
    logs: 
    - {key: LOG_KEY(string), value: LOG_VALUE(string)}
    ...
    peer: PEER(string)
    peerId: PEER_ID(int)
    refs:
    - {
       parentSpanId: PARENT_SPAN_ID(int), 
       parentTraceSegmentId: PARENT_TRACE_SEGMENT_ID(string), 
       entryServiceName: ENTRY_SERVICE_NAME(string), 
       networkAddress: NETWORK_ADDRESS(string),
       parentServiceName: PARENT_SERVICE_NAME(string),
       entryApplicationInstanceId: ENTRY_APPLICATION_INSTANCE_ID(int) 
     }
   ...
```

以下对各个校验字段的描述:

| 字段      | 描述                                                                                                                                                                                                                                  |
|:---           | ---                                                                                                                                                                                                                                    |
| operationName | Span的Operation Name                                                                                                                                                                                                                   |
| operationId   | OperationName对应的Id, 这个值目前为0                                                                                                                                                                                                   |
| parentSpanId  | Span的父级Span的Id.  **注意**: 第一个Span的parentSpanId为-1                                                                                                                                                                                                               |
| spanId        | Span的Id. **注意**: ID是从0开始.                                                                                                                                                                                                                     |
| startTime     | Span开始时间. 目前不支持精确匹配，只需判断不为0即可                                                                                                                                                                                                     |
| endTime       | Span的结束时间.目前不支持精确匹配，只需判断不为0即可                                                                                                                                                                                                                |
| isError       | 是否出现异常. 如果Span抛出异常或者状态码大于400，该值为true, 否则为false                                                                                                                                                                            |
| componentName | 对应组件的名字。官方提供的[Component](https://github.com/apache/incubator-skywalking/blob/master/apm-protocol/apm-network/src/main/java/org/apache/skywalking/apm/network/trace/component/OfficialComponent.java)，则该值为null. |
| componentId   | 组件对应的ID. 。如果是官方提供的[Component](https://github.com/apache/incubator-skywalking/blob/master/apm-protocol/apm-network/src/main/java/org/apache/skywalking/apm/network/trace/component/OfficialComponent.java)，则该值为定义的组件ID   |
| tags          | Span设置的Tag. **注意**: tag的顺序即为在插件中设置的顺序                                                                                                                                                                                         |
| logs          | Span设置的log. **注意**: 顺序为设置Log的顺序                                                                                                                                                                                                      |
| SpanLayer     | 设置的SpanLayer. 目前可能的值为: DB, RPC_FRAMEWORK, HTTP, MQ, CACHE                                                                                                                                                                    |
| SpanType      | Span的类型. 目前的取值为 Exit, Entry, Local                                                                                                                                                                                            |
| peer          | 访问的远端IP. Exit类型的Span, 该值非空                                                                                                                                                                                                                       |
| peerId        | 访问的远端IP的ID，该值目前为0                                                                                                                                                                                                                          |

以下对SegmentRef各个校验字段的描述:

| 字段                   | 描述                                                                                                                                                                                                    |
|:----                       |:----                                                                                                                                                                                                    |
| parentSpanId               | 调用端的SpanID. 例如HttpClient是由SegmentA的SpanID为1的调用的，所以该值为1                                                                                                                              |
| parentTraceSegmentId       | 调用端的SegmentID. 格式: ${APPLICATION_CODE[SEGMENT_INDEX]}, `SEGMENT_INDEX`是相对于期望文件的INDEX. 例如SegmentB由`httpclient-case`中的第0个Segment调用的，所以这个值为`${httpclient-case[0]}`     |
| entryServiceName           | 调用链入口的Segment的服务名词. 例如HttpClient的entryServiceName为`/httpclient-case/case/httpclient`                                                                                                                                                                                          |
| networkAddress             | 被调用者的网络地址。例如CaseServlet通过127.0.0.1:8080调用到ContextPropagateServlet,所以这个值为127.0.0.1:8080                                                                                             |
| parentServiceName          | 调用端的SpanID等于0的OperationName                                                                                                                                                                      |
| entryApplicationInstanceId | 调用链入口的实例ID。                                                                                                                                                                

#### 编写期望数据流程
1. 编写RegistryItems

HttpClient测试用例中运行在Tomcat容器中，所以httpclient的实例数为1, 并且applicationId不为0。HttpClient Span的OperationName和ContextPropagateServlet生成的Span的OperationName一致，所以operationNames中只有两个operationName.
```yml
registryItems:
  applications:
  - {httpclient-case: nq 0}
  instances:
  - {httpclient-case: 1}
  operationNames:
  - httpclient-case: [/httpclient-case/case/httpclient,/httpclient-case/case/context-propagate]
```

2. 编写segmentItems

根据HttpClient用例的运行流程，推断httpclient-case产生两个Segment. 第一个Segment是访问CaseServlet所产生的, 暂且叫它`SegmentA`。第二Segment是ContextPropagateServlet所产生的, 暂且叫它`SegmentB`.

```yml
segments:
  - applicationCode: httpclient-case
    segmentSize: 2
```

Skywalking支持Tomcat埋点，所以SegmentA中会包含两个Span，第一个Span是Tomcat的埋点，第二个Span是HttpClient的埋点.

SegmentA的生成的Span数据如下：
```yml
    - segmentId: not null
      spans:
        -
          operationName: /httpclient-case/case/context-propagate
          operationId: eq 0
          parentSpanId: 0
          spanId: 1
          startTime: nq 0
          endTime: nq 0
          isError: false
          spanLayer: Http
          spanType: Exit
          componentName: null
          componentId: eq 2
          tags:
            - {key: url, value: 'http://127.0.0.1:8080/httpclient-case/case/context-propagate'}
            - {key: http.method, value: GET}
          logs: []
          peer: null
          peerId: eq 0
        -
          operationName: /httpclient-case/case/httpclient
          operationId: eq 0
          parentSpanId: -1
          spanId: 0
          startTime: nq 0
          endTime: nq 0
          spanLayer: Http
          isError: false
          spanType: Entry
          componentName: null
          componentId: 1
          tags:
            - {key: url, value: 'http://localhost:{SERVER_OUTPUT_PORT}/httpclient-case/case/httpclient'}
            - {key: http.method, value: GET}
          logs: []
          peer: null
          peerId: eq 0
```

SegmentB由于Skywalking对于Tomcat进行埋点会产生一个Span，并且SegmentA传递ContextTrace给SegmentB，对于SegmentB需要校验SegmentRef数据.

SegmentB的Span校验数据格式如下：
```yml
- segmentId: not null
  spans:
  -
   operationName: /httpclient-case/case/context-propagate
   operationId: eq 0
   parentSpanId: -1
   spanId: 0
   tags: 
   - {key: url, value: 'http://127.0.0.1:8080/httpclient-case/case/context-propagate'}
   - {key: http.method, value: GET}
   logs: []
   startTime: nq 0
   endTime: nq 0
   spanLayer: Http
   isError: false
   spanType: Entry
   componentName: null
   componentId: 1
   peer: null
   peerId: eq 0
   refs: 
   - {parentSpanId: 1, parentTraceSegmentId: "${httpclient-case[0]}", entryServiceName: "/httpclient-case/case/httpclient", networkAddress: "127.0.0.1:8080",parentServiceName: "/httpclient-case/case/httpclient",entryApplicationInstanceId: nq 0 }
```

### 编写用例配置文件
1. 添加testcase.yaml文件

testcase.yaml文件格式如下:
```yml
testcase:
  request_url: TESTCASE_REQUEST_URL 
  test_framework: TEST_FRAMEWORK_NAME 
  support_versions:
    - VERSION
```

以下对各个字段的描述:

| 字段             | 描述                                                                 |
|:---              |:---                                                                    |
| request_url      | 用例工程暴露的Web服务的地址, URL中的端口用`{SERVER_OUTPUT_PORT}`替代.  |
| test_framework   | 测试框架的名字. 例如HttpClient测试工程使用HttpClient作为test_framework |
| support_versions | 支持框架的版本列表                                                    |

以下为HttpClient的testcase.yaml文件:
```yml
testcase:
  request_url: http://localhost:{SERVER_OUTPUT_PORT}/httpclient-case/case/httpclient 
  support_versions:
    - 4.3
    ...
    - 4.5.3
```

2. 添加Profile配置

在pom.xml中添加`profiles`配置节点。其中每一个`profile`就代表中`testcase.yaml`中support_versions列表中的一个, `profile`中的id命名格式为: `${project.dir_name}-${support_version}`.
HttpClient支持4.3到4.5.3 14个版本, 所以在pom.xml中添加14个`profile`，如下:
```xml
<profiles>
    <profile>
        <id>httpclient-4.3.x-scenario-4.5.3</id>
        <properties>
            <test.framework.version>4.5.3</test.framework.version>
        </properties>
    </profile>
    ....
    <profile>
        <id>httpclient-4.3.x-scenario-4.3</id>
        <properties>
            <test.framework.version>4.3</test.framework.version>
        </properties>
    </profile>
</profiles>
```


## 运行测试用例

### 安装环境
运行测试用例目前需要在本地安装以下环境:
* docker
* docker-compose
* maven
* git

### 运行测试用例

```shell
# export project_name=httpclient-4.3.x-scenario
# export agent_repository_branch=master
# export agent_repository_url=https://github.com/apache/incubator-skywalking.git
# sh ${SKYWALKING_AGENT_TESTCASES_HOME}/deploy-test.sh \
-p ${project_name} \
-b ${agent_repository_branch} \
-r ${agent_repository_url}
```
脚本运行参数的描述:

| 运行参数                   | 描述                                                                            |
| :---                       | :---                                                                            |
| -p project_dir_name        | 指定测试用例进行测试. 默认运行所有的测试用例工程                             |
| -b agent_repository_branch | Skywalking工程的分支名. 默认为`master`                                          |
| -r agent_repository_url    | Skywalking工程的URL. 默认为`https://github.com/apache/incubator-skywalking.git` |

### 查看生成报告
测试用例运行完成之后，会生成报告. 报告生成路径:
`${SKYWALKING_AGENT_TESTCASES_HOME}/workspace/report/{CURRENT_YEAR}/{CURRENT_MONTH}/{COMMITTER}/testreport-{TEST_DATE}.md`

以下对路径中的字段的描述:

| 字段          | 描述                                         |
| :---          | :---                                         |
| CURRENT_YEAR  | 测试的年份                                   |
| CURRENT_MONTH | 测试的月份                                   |
| COMMITTER     | Skywalking工程的地址中的用户名. 默认为apache |
| TEST_DATE     | 测试的时间                                   |

### 查看校验日志
校验的完整日志路径:
`${SKYWALKING_AGENT_TESTCASES_HOME}/workspace/logs/validate-{CURRENT_DATE}.log`


¹ `mock-collector`用来模拟Collector来接受探针上传的数据，源码地址:https://github.com/SkywalkingTest/skywalking-mock-collector.git.
